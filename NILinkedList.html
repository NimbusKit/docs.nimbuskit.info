<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6-nimbuskit"/>
<title>NimbusKit: NILinkedList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="appledocs.css" rel="stylesheet" type="text/css"/>
<link href="nimbuskit.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24278774-1']);
  _gaq.push(['_setDomainName', 'nimbuskit.info']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<a href="index.html"><img style="float:left" src="nimbus128.png" width="80" height="80" /></a>
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NimbusKit
   &#160;<span id="projectnumber">1.2.1 - <a href="http://github.com/jverkoey/nimbus">Fork Nimbus on Github</a> - <a href="http://wiki.nimbuskit.info/">Visit the Nimbus Wiki</a></span>
   </div>
   <div id="projectbrief">The iOS framework that grows only as fast as its documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6-nimbuskit -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('NILinkedList.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classNILinkedList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NILinkedList Class Reference<div class="ingroups"><a class="el" href="Data-Structures.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>A singly linked list implementation. </p>
<p>This data structure provides constant time insertion and deletion of objects in a collection.</p>
<p>A linked list is different from an NSMutableArray solely in the runtime of adding and removing objects. It is always possible to remove objects from both the beginning and end of a linked list in constant time, contrasted with an NSMutableArray where removing an object from the beginning of the list could result in O(N) linear time, where N is the number of objects in the collection when the action is performed. If an object's location is known, it is possible to get O(1) constant time removal with a linked list, where an NSMutableArray would get at best O(N) linear time.</p>
<p>This collection implements <a class="el" href="classNSFastEnumeration-Protocol.html">NSFastEnumeration</a> which allows you to use foreach-style iteration on the linked list. If you would like more control over the iteration of the linked list you can use <code>-[<a class="el" href="NILinkedList.html" title="A singly linked list implementation. ">NILinkedList</a> <a class="el" href="NILinkedList.html#objectEnumerator">objectEnumerator</a>]</code></p>
<h2>When You Should Use a Linked List</h2>
<p>Linked lists should be used when you need guaranteed constant-time performance characteristics for adding arbitrary objects to and removing arbitrary objects from a collection that also enforces consistent ordering.</p>
<p>Linked lists are used in <a class="el" href="NIMemoryCache.html" title="An in-memory cache for storing objects with expiration support. ">NIMemoryCache</a> to implement an efficient, least-recently used collection for in-memory caches. It is important that these caches use a collection with guaranteed constant-time properties because in-memory caches must operate as fast as possible in order to avoid locking up the UI. Specifically, in-memory caches could potentially have thousands of objects. Every time we access one of these objects we move its lru placement to the end of the lru list. If we were to use an NSArray for this data structure we could easily run into an O(N^2) exponential-time operation which is absolutely unacceptable.</p>
<h2>Modifying a linked list</h2>
<p>To add an object to a linked list, you may use <a class="el" href="NILinkedList.html#addObject:">addObject:</a>.</p>
<div class="fragment"><div class="line">[ll addObject:object];</div>
</div><!-- fragment --><p>To remove some arbitrary object in linear time (meaning we must perform a scan of the list), use <a class="el" href="NILinkedList.html#removeObject:">removeObject:</a></p>
<div class="fragment"><div class="line">[ll removeObject:object];</div>
</div><!-- fragment --><p>Note that using a linked list in this way is way is identical to using an NSMutableArray in performance time.</p>
<h2>Accessing a Linked List</h2>
<p>You can access the first and last objects with constant time by using <a class="el" href="NILinkedList.html#firstObject">firstObject</a> and <a class="el" href="NILinkedList.html#lastObject">lastObject</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">id</span> <a class="code" href="NILinkedList.html#firstObject">firstObject</a> = ll.firstObject;</div>
<div class="line"><span class="keywordtype">id</span> <a class="code" href="NILinkedList.html#lastObject">lastObject</a> = ll.lastObject;</div>
</div><!-- fragment --><h2>Traversing a Linked List</h2>
<p><a class="el" href="NILinkedList.html" title="A singly linked list implementation. ">NILinkedList</a> implements the <a class="el" href="classNSFastEnumeration-Protocol.html">NSFastEnumeration</a> protocol, allowing you to use foreach-style iteration over the objects of a linked list. Note that you cannot modify a linked list during fast iteration and doing so will fire an assertion.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">id</span> <span class="keywordtype">object</span> in ll) {</div>
<div class="line">  <span class="comment">// perform operations on the object</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If you need to modify the linked list while traversing it, an acceptable algorithm is to successively remove either the head or tail object, depending on the order in which you wish to traverse the linked list.</p>
<h3>Traversing Forward by Removing Objects from the List</h3>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (nil != ll.firstObject) {</div>
<div class="line">  <span class="keywordtype">id</span> <span class="keywordtype">object</span> = [ll <a class="code" href="NILinkedList.html#firstObject">firstObject</a>];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Remove the head of the linked list in constant time.</span></div>
<div class="line">  [ll <a class="code" href="NILinkedList.html#removeFirstObject">removeFirstObject</a>];</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Traversing Backward by Removing Objects from the List</h3>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (nil != ll.lastObject) {</div>
<div class="line">  <span class="keywordtype">id</span> <span class="keywordtype">object</span> = [ll <a class="code" href="NILinkedList.html#lastObject">lastObject</a>];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Remove the tail of the linked list in constant time.</span></div>
<div class="line">  [ll <a class="code" href="NILinkedList.html#removeLastObject">removeLastObject</a>];</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Examples</h2>
<h3>Building a first-in-first-out list of operations</h3>
<div class="fragment"><div class="line"><a class="code" href="NILinkedList.html">NILinkedList</a>* ll = [<a class="code" href="NILinkedList.html">NILinkedList</a> <a class="code" href="NILinkedList.html#linkedList">linkedList</a>];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add the operations to the linked list like you would an array.</span></div>
<div class="line">[ll addObject:operation1];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Each addObject call appends the object to the end of the linked list.</span></div>
<div class="line">[ll addObject:operation2];</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (nil != ll.<a class="code" href="NILinkedList.html#firstObject">firstObject</a>) {</div>
<div class="line">  NSOperation* op1 = [ll <a class="code" href="NILinkedList.html#firstObject">firstObject</a>];</div>
<div class="line">  <span class="comment">// Process the operation...</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Remove the head of the linked list in constant time.</span></div>
<div class="line">  [ll <a class="code" href="NILinkedList.html#removeFirstObject">removeFirstObject</a>];</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Removing an item from the middle of the list</h3>
<div class="fragment"><div class="line"><a class="code" href="NILinkedList.html">NILinkedList</a>* ll = [<a class="code" href="NILinkedList.html">NILinkedList</a> <a class="code" href="NILinkedList.html#linkedList">linkedList</a>];</div>
<div class="line"></div>
<div class="line">[ll addObject:obj1];</div>
<div class="line">[ll addObject:obj2];</div>
<div class="line">[ll addObject:obj3];</div>
<div class="line">[ll addObject:obj4];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Find an object in the linked list in linear time.</span></div>
<div class="line">NILinkedListLocation* location = [ll locationOfObject:obj3];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Remove the object in constant time.</span></div>
<div class="line">[ll removeObjectAtLocation:location];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Location is no longer valid at this point.</span></div>
<div class="line">location = nil;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Remove an object in linear time. This is simply a more concise version of the above.</span></div>
<div class="line">[ll removeObject:obj4];</div>
<div class="line"></div>
<div class="line"><span class="comment">// We would use the NILinkedListLocation to remove the object if we were storing the location</span></div>
<div class="line"><span class="comment">// in an external data structure and wanted constant time removal, for example. See</span></div>
<div class="line"><span class="comment">// NIMemoryCache for an example of this in action.</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="NIMemoryCache.html" title="An in-memory cache for storing objects with expiration support. ">NIMemoryCache</a></dd></dl>
<h3>Using the location object for constant time operations</h3>
<div class="fragment"><div class="line"><a class="code" href="NILinkedList.html">NILinkedList</a>* ll = [<a class="code" href="NILinkedList.html">NILinkedList</a> <a class="code" href="NILinkedList.html#linkedList">linkedList</a>];</div>
<div class="line"></div>
<div class="line">[ll addObject:obj1];</div>
<div class="line">NILinkedListLocation* location = [ll addObject:obj2];</div>
<div class="line">[ll addObject:obj3];</div>
<div class="line">[ll addObject:obj4];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Remove the second object in constant time.</span></div>
<div class="line">[ll removeObjectAtLocation:location];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Location is no longer valid at this point.</span></div>
<div class="line">location = nil;</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Tasks</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying a Linked List</div></td></tr>
<tr class="memitem:count"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#count">count</a></td></tr>
<tr class="separator:count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:firstObject"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#firstObject">firstObject</a></td></tr>
<tr class="separator:firstObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lastObject"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#lastObject">lastObject</a></td></tr>
<tr class="separator:lastObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:allObjects"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#allObjects">allObjects</a></td></tr>
<tr class="separator:allObjects"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:objectEnumerator"><td class="memItemLeft" align="right" valign="top">(NSEnumerator *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#objectEnumerator">objectEnumerator</a></td></tr>
<tr class="separator:objectEnumerator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:containsObject:"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#containsObject:">containsObject:</a></td></tr>
<tr class="separator:containsObject:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:description"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#description">description</a></td></tr>
<tr class="separator:description"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating a Linked List</div></td></tr>
<tr class="memitem:linkedList"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="NILinkedList.html">NILinkedList</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="NILinkedList.html#linkedList">linkedList</a></td></tr>
<tr class="separator:linkedList"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:linkedListWithArray:"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="NILinkedList.html">NILinkedList</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="NILinkedList.html#linkedListWithArray:">linkedListWithArray:</a></td></tr>
<tr class="separator:linkedListWithArray:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:initWithArray:"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#initWithArray:">initWithArray:</a></td></tr>
<tr class="separator:initWithArray:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constant-Time Access</div></td></tr>
<tr class="memitem:locationOfObject:"><td class="memItemLeft" align="right" valign="top">(NILinkedListLocation *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#locationOfObject:">locationOfObject:</a></td></tr>
<tr class="separator:locationOfObject:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:objectAtLocation:"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#objectAtLocation:">objectAtLocation:</a></td></tr>
<tr class="separator:objectAtLocation:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:removeObjectAtLocation:"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#removeObjectAtLocation:">removeObjectAtLocation:</a></td></tr>
<tr class="separator:removeObjectAtLocation:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding Objects</div></td></tr>
<tr class="memitem:addObject:"><td class="memItemLeft" align="right" valign="top">(NILinkedListLocation *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#addObject:">addObject:</a></td></tr>
<tr class="separator:addObject:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addObjectsFromArray:"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#addObjectsFromArray:">addObjectsFromArray:</a></td></tr>
<tr class="separator:addObjectsFromArray:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Removing Objects</div></td></tr>
<tr class="memitem:removeAllObjects"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#removeAllObjects">removeAllObjects</a></td></tr>
<tr class="separator:removeAllObjects"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:removeObject:"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#removeObject:">removeObject:</a></td></tr>
<tr class="separator:removeObject:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:removeFirstObject"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#removeFirstObject">removeFirstObject</a></td></tr>
<tr class="separator:removeFirstObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:removeLastObject"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="NILinkedList.html#removeLastObject">removeLastObject</a></td></tr>
<tr class="separator:removeLastObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="count"></a>
<div class="memitem">
      <h3 class="memname">count</h3>
<div class="memdoc">

<p class="abstract">Returns the number of objects currently in the linked list. </p>
<div class="declaration">
- (NSUInteger)count;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>The number of objects currently in the linked list. </dd></dl>

</div>
</div>
<a class="anchor" id="firstObject"></a>
<div class="memitem">
      <h3 class="memname">firstObject</h3>
<div class="memdoc">

<p class="abstract">Returns the first object in the linked list. </p>
<div class="declaration">
- (id)firstObject;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>The first object in the linked list. If the linked list is empty, returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="lastObject"></a>
<div class="memitem">
      <h3 class="memname">lastObject</h3>
<div class="memdoc">

<p class="abstract">Returns the last object in the linked list. </p>
<div class="declaration">
- (id)lastObject;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>The last object in the linked list. If the linked list is empty, returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="linkedList"></a>
<div class="memitem">
      <h3 class="memname">linkedList</h3>
<div class="memdoc">

<p class="abstract">Returns a newly allocated and autoreleased linked list. </p>
<div class="declaration">
+ (<a class="el" href="NILinkedList.html">NILinkedList</a>*)linkedList;</td></tr>
</div>
<h5>Discussion</h5>
<p>Identical to [[[<a class="el" href="NILinkedList.html" title="A singly linked list implementation. ">NILinkedList</a> alloc] init] autorelease]; </p>

</div>
</div>
<a class="anchor" id="linkedListWithArray:"></a>
<div class="memitem">
      <h3 class="memname">linkedListWithArray:</h3>
<div class="memdoc">

<p class="abstract">Returns a newly allocated and autoreleased linked list filled with the objects from an array. </p>
<div class="declaration">
+ (<a class="el" href="NILinkedList.html">NILinkedList</a>*)linkedListWithArray:(NSArray *)array;</td></tr>
</div>
<h5>Discussion</h5>
<p>Identical to [[[<a class="el" href="NILinkedList.html" title="A singly linked list implementation. ">NILinkedList</a> alloc] initWithArray:array] autorelease]; </p>

</div>
</div>
<a class="anchor" id="initWithArray:"></a>
<div class="memitem">
      <h3 class="memname">initWithArray:</h3>
<div class="memdoc">

<p class="abstract">Initializes a newly allocated linked list by placing in it the objects contained in a given array. </p>
<div class="declaration">
- (id)initWithArray:(NSArray *)anArray;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anArray</td><td>An array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linked list initialized to contain the objects in anArray. </dd></dl>

</div>
</div>
<a class="anchor" id="allObjects"></a>
<div class="memitem">
      <h3 class="memname">allObjects</h3>
<div class="memdoc">

<p class="abstract">Returns an array containing the linked list's objects, or an empty array if the linked list has no objects. </p>
<div class="declaration">
- (NSArray*)allObjects;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>An array containing the linked list's objects, or an empty array if the linked list has no objects. The objects will be in the same order as the linked list. </dd></dl>

</div>
</div>
<a class="anchor" id="objectEnumerator"></a>
<div class="memitem">
      <h3 class="memname">objectEnumerator</h3>
<div class="memdoc">

<p class="abstract">Returns an enumerator object that lets you access each object in the linked list. </p>
<div class="declaration">
- (NSEnumerator*)objectEnumerator;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>An enumerator object that lets you access each object in the linked list, in order, from the first object to the last. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>When you use this method you must not modify the linked list during enumeration. </dd></dl>

</div>
</div>
<a class="anchor" id="containsObject:"></a>
<div class="memitem">
      <h3 class="memname">containsObject:</h3>
<div class="memdoc">

<p class="abstract">Returns a Boolean value that indicates whether a given object is present in the linked list. </p>
<div class="declaration">
- (BOOL)containsObject:(id)anObject;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(count) linear</p>
<dl class="section return"><dt>Returns</dt><dd>YES if anObject is present in the linked list, otherwise NO. </dd></dl>

</div>
</div>
<a class="anchor" id="description"></a>
<div class="memitem">
      <h3 class="memname">description</h3>
<div class="memdoc">

<p class="abstract">Returns a string that represents the contents of the linked list, formatted as a property list. </p>
<div class="declaration">
- (NSString*)description;</td></tr>
</div>
<h5>Discussion</h5>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the contents of the linked list, formatted as a property list. </dd></dl>

</div>
</div>
<a class="anchor" id="locationOfObject:"></a>
<div class="memitem">
      <h3 class="memname">locationOfObject:</h3>
<div class="memdoc">

<p class="abstract">Searches for an object in the linked list. </p>
<div class="declaration">
- (NILinkedListLocation*)locationOfObject:(id)object;</td></tr>
</div>
<h5>Discussion</h5>
<p>The NILinkedListLocation object will remain valid as long as the object is still in the linked list. Once the object is removed from the linked list, however, the location object is released from memory and should no longer be used.</p>
<p>TODO (jverkoey July 1, 2011): Consider creating a wrapper object for the location so that we can deal with incorrect usage more safely.</p>
<p>Run-time: O(count) linear</p>
<dl class="section return"><dt>Returns</dt><dd>A location within the linked list. </dd></dl>

</div>
</div>
<a class="anchor" id="objectAtLocation:"></a>
<div class="memitem">
      <h3 class="memname">objectAtLocation:</h3>
<div class="memdoc">

<p class="abstract">Retrieves the object at a specific location. </p>
<div class="declaration">
- (id)objectAtLocation:(NILinkedListLocation *)location;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(1) constant </p>

</div>
</div>
<a class="anchor" id="removeObjectAtLocation:"></a>
<div class="memitem">
      <h3 class="memname">removeObjectAtLocation:</h3>
<div class="memdoc">

<p class="abstract">Removes an object at a predetermined location. </p>
<div class="declaration">
- (void)removeObjectAtLocation:(NILinkedListLocation *)location;</td></tr>
</div>
<h5>Discussion</h5>
<p>It is assumed that this location still exists in the linked list. If the object this location refers to has since been removed then this method will have undefined results.</p>
<p>This is provided as an optimization over the O(n) removal method but should be used with care. </p>
<pre class="fragment"> Run-time: O(1) constant</pre> 
</div>
</div>
<a class="anchor" id="addObject:"></a>
<div class="memitem">
      <h3 class="memname">addObject:</h3>
<div class="memdoc">

<p class="abstract">Appends an object to the linked list. </p>
<div class="declaration">
- (NILinkedListLocation*)addObject:(id)object;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(1) constant</p>
<dl class="section return"><dt>Returns</dt><dd>A location within the linked list. </dd></dl>

</div>
</div>
<a class="anchor" id="addObjectsFromArray:"></a>
<div class="memitem">
      <h3 class="memname">addObjectsFromArray:</h3>
<div class="memdoc">

<p class="abstract">Appends an array of objects to the linked list. </p>
<div class="declaration">
- (void)addObjectsFromArray:(NSArray *)array;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(l) linear with the length of the given array </p>

</div>
</div>
<a class="anchor" id="removeAllObjects"></a>
<div class="memitem">
      <h3 class="memname">removeAllObjects</h3>
<div class="memdoc">

<p class="abstract">Removes all objects from the linked list. </p>
<div class="declaration">
- (void)removeAllObjects;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: Theta(count) linear </p>

</div>
</div>
<a class="anchor" id="removeObject:"></a>
<div class="memitem">
      <h3 class="memname">removeObject:</h3>
<div class="memdoc">

<p class="abstract">Removes an object from the linked list. </p>
<div class="declaration">
- (void)removeObject:(id)object;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(count) linear </p>

</div>
</div>
<a class="anchor" id="removeFirstObject"></a>
<div class="memitem">
      <h3 class="memname">removeFirstObject</h3>
<div class="memdoc">

<p class="abstract">Removes the first object from the linked list. </p>
<div class="declaration">
- (void)removeFirstObject;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(1) constant </p>

</div>
</div>
<a class="anchor" id="removeLastObject"></a>
<div class="memitem">
      <h3 class="memname">removeLastObject</h3>
<div class="memdoc">

<p class="abstract">Removes the last object from the linked list. </p>
<div class="declaration">
- (void)removeLastObject;</td></tr>
</div>
<h5>Discussion</h5>
<p>Run-time: O(1) constant </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<script type="text/javascript" src="widget.js"></script>
</body>
</html>
